# GitHub Actions Workflow: Opus Build for Windows, Linux, and Linux ARM
#
# This workflow automates the compilation of the Opus project for Windows (x64), Linux (x64),
# and Linux ARM (64-bit). It is triggered on pushes to the 'main' branch, and now automatically
# creates a tag and release for each successful build on 'main'. It also still triggers on
# manually pushed version tags. Build artifacts are named using the UTC date and time of the build.
#
# Action Version: 1.0.8
# Last Updated: 2025-06-15
# Description of Changes:
#   - Updated Action Version and Last Updated.
#   - Confirmed that compiled binaries are uploaded as release assets.
#   - Corrected Linux ARM job to use QEMU emulation on a standard x64 Ubuntu runner.
#     Removed the unsupported 'architecture' key to fix workflow validation error.
#   - Added 'docker/setup-qemu-action' and 'docker/setup-buildx-action' for ARM emulation.
#   - Ensured all comments are in English.
#
# For more information on GitHub Actions, visit: https://docs.github.com/en/actions
#

# Workflow name that will appear in GitHub Actions
name: Build Opus for Windows, Linux, and Linux ARM

# Defines when the workflow will be executed
on:
  # Triggers the workflow on 'push' events to the 'main' branch
  push:
    branches:
      - main
    tags:
      - 'v*.*.*' # Example: v1.0.0, v1.2.3 (still supported for manual tagging)

  # Allows you to manually run this workflow from the GitHub "Actions" tab
  workflow_dispatch:

# Definition of the jobs to be executed
jobs:
  # Job for Windows compilation
  build-windows:
    name: Build on Windows
    # Uses the latest Windows Server version
    runs-on: windows-latest

    outputs:
      build_version: ${{ steps.date.outputs.BUILD_VERSION }} # Output the build version for other jobs

    steps:
      # Step 0: Capture build date and time to use as version
      - name: Get current date and time
        id: date
        run: |
          # Formats the date and time as YYYYMMDD-HHMMSS (UTC)
          $build_version = (Get-Date -UFormat %Y%m%d-%H%M%S)
          echo "BUILD_VERSION=$build_version" | Out-File -FilePath $env:GITHUB_ENV -Append
          echo "BUILD_VERSION=$build_version" | Out-File -FilePath $env:GITHUB_OUTPUT -Append # Output for job dependencies
        shell: powershell

      # Step 1: Checks out your repository code
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive # If there are submodules, they will also be cloned

      # Step 2: Configures the build environment with CMake
      # CMake is pre-installed on GitHub Actions runners
      - name: Configure CMake for Windows
        run: |
          # Creates a build directory
          mkdir build-windows
          cd build-windows
          # Configures CMake.
          # -DCMAKE_BUILD_TYPE=Release: Sets the build type to Release (optimized).
          # ..: Points to the project root directory where CMakeLists.txt is located.
          cmake .. -DCMAKE_BUILD_TYPE=Release -A x64
        # shell: cmd is used to ensure compatibility in Windows environments

      # Step 3: Compiles the project
      - name: Build Opus for Windows
        run: |
          cd build-windows
          # Compiles the project using the configuration generated by CMake
          cmake --build . --config Release

      # Step 4: Compresses build artifacts
      - name: Archive Windows builds
        run: |
          # The exact path of artifacts may vary.
          # Adjust according to where Opus files are generated (e.g., build-windows\Release\*)
          # This example attempts to copy generated files to a temporary folder and compress them.
          # You will need to check the output structure of your CMake build for 'opusfile'.
          mkdir windows_artifacts
          # Using 7-Zip (available on the Windows runner) to create the zip file
          7z a opus-windows-x64-${{ env.BUILD_VERSION }}.zip build-windows\Release\ # Adjusted to use BUILD_VERSION
        shell: powershell

      # Step 5: Uploads artifacts
      - name: Upload Windows artifacts
        uses: actions/upload-artifact@v4
        with:
          # Artifact name
          name: opus-windows-x64-${{ env.BUILD_VERSION }} # Adjusted to use BUILD_VERSION
          # Path to the file or directory to be uploaded
          path: opus-windows-x64-${{ env.BUILD_VERSION }}.zip


  # Job for Linux compilation (x64)
  build-linux:
    name: Build on Linux (x64)
    # Uses the latest Ubuntu version (x64 by default)
    runs-on: ubuntu-latest

    outputs:
      build_version: ${{ steps.date.outputs.BUILD_VERSION }} # Output the build version for other jobs

    steps:
      # Step 0: Capture build date and time to use as version
      - name: Get current date and time
        id: date
        run: |
          # Formats the date and time as YYYYMMDD-HHMMSS (UTC)
          echo "BUILD_VERSION=$(date -u +%Y%m%d-%H%M%S)" >> "$GITHUB_ENV"
          echo "BUILD_VERSION=$(date -u +%Y%m%d-%H%M%S)" >> "$GITHUB_OUTPUT" # Output for job dependencies

      # Step 1: Checks out your repository code
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive

      # Step 2: Installs build tools (CMake, make, etc.)
      # GCC and G++ are pre-installed, but it's good to ensure CMake and essential tools
      - name: Install build dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y cmake build-essential libogg-dev libflac-dev # libogg-dev and libflac-dev may be needed for opusfile

      # Step 3: Configures the build environment with CMake
      - name: Configure CMake for Linux
        run: |
          mkdir build-linux
          cd build-linux
          cmake .. -DCMAKE_BUILD_TYPE=Release # Release compilation for optimization

      # Step 4: Compiles the project
      - name: Build Opus for Linux
        run: |
          cd build-linux
          cmake --build . --config Release # Uses 'make' underneath

      # Step 5: Compresses build artifacts
      - name: Archive Linux builds
        run: |
          # Compresses the content of the 'build-linux' directory.
          # The '-C build-linux' changes to the directory before adding '.' (current content).
          # This ensures that the root of the tar.gz file is the content of build-linux, and not build-linux/build-linux/...
          tar -czvf opus-linux-x64-${{ env.BUILD_VERSION }}.tar.gz -C build-linux .
      # Explicit 'shell: /usr/bin/bash -e {0}' is not necessary, default is bash on Linux

      # Step 6: Uploads artifacts
      - name: Upload Linux artifacts
        uses: actions/upload-artifact@v4
        with:
          name: opus-linux-x64-${{ env.BUILD_VERSION }} # Adjusted to use BUILD_VERSION
          path: opus-linux-x64-${{ env.BUILD_VERSION }}.tar.gz

  # Job for Linux ARM compilation (64-bit)
  build-linux-arm:
    name: Build on Linux ARM (64-bit)
    # Uses the latest Ubuntu version for x64, and then sets up ARM64 emulation
    runs-on: ubuntu-latest

    outputs:
      build_version: ${{ steps.date.outputs.BUILD_VERSION }} # Output the build version for other jobs

    steps:
      # Step 0: Capture build date and time to use as version
      - name: Get current date and time
        id: date
        run: |
          # Formats the date and time as YYYYMMDD-HHMMSS (UTC)
          echo "BUILD_VERSION=$(date -u +%Y%m%d-%H%M%S)" >> "$GITHUB_ENV"
          echo "BUILD_VERSION=$(date -u +%Y%m%d-%H%M%S)" >> "$GITHUB_OUTPUT" # Output for job dependencies

      # Step 1: Set up QEMU for ARM64 emulation
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        with:
          platforms: all

      # Step 2: Set up Docker Buildx for multi-platform builds
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Step 3: Checks out your repository code
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive

      # Step 4: Installs build tools (CMake, make, etc.)
      - name: Install build dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y cmake build-essential libogg-dev libflac-dev # Dependencies likely similar for ARM

      # Step 5: Configures the build environment with CMake
      # We explicitly set the CMAKE_SYSTEM_PROCESSOR to aarch64 for ARM builds
      - name: Configure CMake for Linux ARM
        run: |
          mkdir build-linux-arm
          cd build-linux-arm
          cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_SYSTEM_PROCESSOR=aarch64 # Explicitly target ARM64
          # If opusfile requires a specific toolchain file for cross-compilation, you would add it here
          # For simple projects, setting CMAKE_SYSTEM_PROCESSOR might be enough with QEMU.

      # Step 6: Compiles the project
      - name: Build Opus for Linux ARM
        run: |
          cd build-linux-arm
          cmake --build . --config Release # Uses 'make' underneath

      # Step 7: Compresses build artifacts
      - name: Archive Linux ARM builds
        run: |
          # Compresses the content of the 'build-linux-arm' directory.
          tar -czvf opus-linux-arm64-${{ env.BUILD_VERSION }}.tar.gz -C build-linux-arm .

      # Step 8: Uploads artifacts
      - name: Upload Linux ARM artifacts
        uses: actions/upload-artifact@v4
        with:
          name: opus-linux-arm64-${{ env.BUILD_VERSION }} # Adjusted to use BUILD_VERSION
          path: opus-linux-arm64-${{ env.BUILD_VERSION }}.tar.gz

  # Job to create GitHub Release
  create-release:
    name: Create GitHub Release
    # This job runs only if all build jobs succeed
    needs: [build-windows, build-linux, build-linux-arm]
    # Removed the 'if' condition, so this job now runs for every successful build on 'main'.
    runs-on: ubuntu-latest

    steps:
      # Step 0: Set the tag name based on the build version
      # We need to get the BUILD_VERSION from one of the previous jobs.
      # Since all jobs have the same BUILD_VERSION, we can pick one, e.g., build-windows.
      - name: Set Release Tag Name
        id: set_tag
        run: |
          echo "RELEASE_TAG=build-${{ needs.build-windows.outputs.build_version }}" >> $GITHUB_ENV

      # Step 1: Download all build artifacts
      - name: Download all build artifacts
        uses: actions/download-artifact@v4
        with:
          # Downloads all artifacts from the current workflow run
          path: ./artifacts

      # Step 2: Create GitHub Release and upload assets
      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          # Set the tag name for the release. This action will create the tag if it doesn't exist.
          tag_name: ${{ env.RELEASE_TAG }}
          # Set the release name
          name: Automated Build Release ${{ env.RELEASE_TAG }}
          # Provide a body for the release notes
          body: |
            Automated build for branch `main`.
            Build Date (UTC): `${{ needs.build-windows.outputs.build_version }}`
          # Set 'prerelease' to true if you want these auto-generated releases to be marked as pre-releases.
          # Remove or set to 'false' if you want them as full releases.
          # prerelease: true
          files: |
            ./artifacts/opus-windows-x64-${{ needs.build-windows.outputs.build_version }}.zip
            ./artifacts/opus-linux-x64-${{ needs.build-linux.outputs.build_version }}.tar.gz
            ./artifacts/opus-linux-arm64-${{ needs.build-linux-arm.outputs.build_version }}.tar.gz
        env:
          # GITHUB_TOKEN is automatically provided by GitHub Actions for authentication
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
