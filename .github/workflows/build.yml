# GitHub Actions Workflow: Opus Build for Windows, Linux, and Linux ARM
#
# This workflow automates the compilation of the Opus project for Windows (x64), Linux (x64),
# and Linux ARM (64-bit). It is triggered on pushes to the 'main' branch, and now automatically
# creates a tag and release for each successful build on 'main'. It also still triggers on
# manually pushed version tags. Build artifacts are named using the UTC date and time of the build.
#
# Version: 1.0.23
# Last Updated: 2025-06-16 13:28 GMT-3
#
# Description of Changes:
#   - Updated Action Version and Last Updated.
#   - Confirmed that compiled binaries are uploaded as release assets.
#   - Corrected file paths in 'create-release' job's 'files' section to correctly include
#     subdirectories created by 'actions/download-artifact', ensuring assets are uploaded.
#   - Corrected Linux ARM job to use QEMU emulation on a standard x64 Ubuntu runner.
#     Removed the unsupported 'architecture' key to fix workflow validation error.
#   - Added 'docker/setup-qemu-action' and 'docker/setup-buildx-action' for ARM emulation.
#   - Ensured all comments are in English.
#   - Added steps to handle Opus header file discovery/installation in build jobs.
#     - For Linux builds, `libopus-dev` is now explicitly installed.
#     - For Windows builds, assuming Opus source is within the repo, CMake configuration remains
#       reliant on standard CMake project practices. If Opus is an external dependency,
#       additional steps (e.g., vcpkg) might be needed.
#   - CRITICAL FIX for ARM build: Changed ARM build to use a multi-architecture Docker
#     image for cross-compilation, bypassing apt-get package availability issues.
#   - **FIXED Permission Denied Error in ARM build:** Added `chown` command inside Docker
#     container to set ownership of generated files to the host user, allowing artifacts
#     to be moved and archived successfully.
#   - Added inclusion of .h headers in build outputs:
#     - For Linux/ARM: Copies from `/usr/include/opus/` (system installation path).
#     - For Windows: Corrected header path to 'include' (from repository root) based on diagnostic output.
#   - All comments in the code are now in English.
#
# For more information on GitHub Actions, visit: https://docs.github.com/en/actions
#

# Workflow name that will appear in GitHub Actions
name: Build Opus for Windows, Linux, and Linux ARM

# Defines when the workflow will be executed
on:
  # Triggers the workflow on 'push' events to the 'main' branch
  push:
    branches:
      - main
    tags:
      - 'v*.*.*' # Example: v1.0.0, v1.2.3 (still supported for manual tagging)

  # Allows you to manually run this workflow from the GitHub "Actions" tab
  workflow_dispatch:

# Definition of the jobs to be executed
jobs:
  # Job for Windows compilation
  build-windows:
    name: Build on Windows
    # Uses the latest Windows Server version
    runs-on: windows-latest

    outputs:
      build_version: ${{ steps.date.outputs.BUILD_VERSION }} # Output the build version for other jobs

    steps:
      # Step 0: Capture build date and time to use as version
      - name: Get current date and time
        id: date
        run: |
          # Formats the date and time as INSEE_MMDD-HHMMSS (UTC)
          $build_version = (Get-Date -UFormat %Y%m%d-%H%M%S)
          echo "BUILD_VERSION=$build_version" | Out-File -FilePath $env:GITHUB_ENV -Append
          echo "BUILD_VERSION=$build_version" | Out-File -FilePath $env:GITHUB_OUTPUT -Append # Output for job dependencies
        shell: powershell

      # Step 1: Checks out your repository code
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive # If there are submodules, they will also be cloned

      # DIAGNOSTIC STEP: List repository contents to find the correct header path
      - name: List repository contents (for debugging Opus headers)
        run: |
          Get-ChildItem -Path . -Recurse -Depth 3 | Select-Object FullName, Attributes, Mode | Format-Table -Wrap
        shell: powershell

      # Step 2: Configure the build environment with CMake
      # CMake is pre-installed on GitHub Actions runners
      - name: Configure CMake for Windows
        run: |
          # Creates a build directory
          mkdir build-windows
          cd build-windows
          # Configures CMake.
          # -DCMAKE_BUILD_TYPE=Release: Sets the build type to Release (optimized).
          # ..: Points to the project root directory where CMakeLists.txt is located.
          cmake .. -DCMAKE_BUILD_TYPE=Release -A x64
        # shell: cmd is used to ensure compatibility in Windows environments

      # Step 3: Compiles the project
      - name: Build Opus for Windows
        run: |
          cd build-windows
          # Compiles the project using the configuration generated by CMake
          cmake --build . --config Release

      # Step 4: Compresses build artifacts (MODIFIED to include .h headers from local repository)
      - name: Archive Windows builds
        run: |
          # Define the path to the Opus headers relative to the repository root
          # Based on diagnostic output, headers are directly in 'include' directory at repo root.
          $repo_root = $env:GITHUB_WORKSPACE # This is the path to the root of your checked-out repository
          $opus_include_src_path = Join-Path $repo_root "include" # Corrected path
          
          # Check if the headers directory exists
          if (-not (Test-Path $opus_include_src_path)) {
            Write-Error "Opus headers directory '$opus_include_src_path' not found in the repository. Please verify the repository structure using the 'List repository contents' step output."
            exit 1
          }

          # Creates a staging directory to group artifacts and headers
          mkdir dist_windows
          mkdir dist_windows\bin
          Copy-Item -Path "build-windows\Release\*" -Destination "dist_windows\bin\" -Recurse -Force

          # Copies Opus headers from the local repository
          # The destination path is now 'dist_windows\include\opus' to maintain standard SDK structure
          mkdir dist_windows\include
          mkdir dist_windows\include\opus
          Copy-Item -Path "$opus_include_src_path\*" -Destination "dist_windows\include\opus\" -Recurse -Force

          # Uses 7-Zip to create the zip file with binaries and headers
          7z a opus-windows-x64-${{ env.BUILD_VERSION }}.zip dist_windows\*
        shell: pwsh # Using pwsh (PowerShell Core) for more consistent behavior

      # Step 5: Uploads artifacts
      - name: Upload Windows artifacts
        uses: actions/upload-artifact@v4
        with:
          # Artifact name
          name: opus-windows-x64-${{ env.BUILD_VERSION }} # Adjusted to use BUILD_VERSION
          # Path to the file or directory to be uploaded
          path: opus-windows-x64-${{ env.BUILD_VERSION }}.zip


  # Job for Linux compilation (x64)
  build-linux:
    name: Build on Linux (x64)
    # Uses the latest Ubuntu version (x64 by default)
    runs-on: ubuntu-latest

    outputs:
      build_version: ${{ steps.date.outputs.BUILD_VERSION }} # Output the build version for other jobs

    steps:
      # Step 0: Capture build date and time to use as version
      - name: Get current date and time
        id: date
        run: |
          # Formats the date and time as INSEE_MMDD-HHMMSS (UTC)
          echo "BUILD_VERSION=$(date -u +%Y%m%d-%H%M%S)" >> "$GITHUB_ENV"
          echo "BUILD_VERSION=$(date -u +%Y%m%d-%H%M%S)" >> "$GITHUB_OUTPUT" # Output for job dependencies

      # Step 1: Checks out your repository code
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive

      # Step 2: Installs build tools (CMake, make, etc.) and Opus development headers
      - name: Install build dependencies and Opus development headers
        run: |
          sudo apt-get update
          # `libopus-dev` provides `opus.h` and other necessary development files for Opus.
          # `libogg-dev` and `libflac-dev` are also included as they might be dependencies
          # for projects using Opus (e.g., opusfile).
          sudo apt-get install -y cmake build-essential libogg-dev libflac-dev libopus-dev

      # Step 3: Configures the build environment with CMake
      - name: Configure CMake for Linux
        run: |
          mkdir build-linux
          cd build-linux
          cmake .. -DCMAKE_BUILD_TYPE=Release # Release compilation for optimization

      # Step 4: Compiles the project
      - name: Build Opus for Linux
        run: |
          cd build-linux
          cmake --build . --config Release # Uses 'make' underneath

      # Step 5: Compresses build artifacts (MODIFIED to include .h headers)
      - name: Archive Linux builds
        run: |
          # Creates a staging directory
          mkdir dist_linux
          mkdir dist_linux/bin
          mkdir -p dist_linux/include/opus # Creates nested directories for headers

          # Copies compiled artifacts (assuming output is directly in build-linux)
          cp -r build-linux/* dist_linux/bin/

          # Copies Opus headers from the system installation directory
          cp -r /usr/include/opus/* dist_linux/include/opus/

          # Compresses the content of the 'dist_linux' directory.
          # The '-C dist_linux' changes to the directory before adding '.' (current content).
          # This ensures that the root of the tar.gz file is the content of dist_linux, not dist_linux/dist_linux/...
          tar -czvf opus-linux-x64-${{ env.BUILD_VERSION }}.tar.gz -C dist_linux .
      # Explicit 'shell: /usr/bin/bash -e {0}' is not necessary, default is bash on Linux

      # Step 6: Uploads artifacts
      - name: Upload Linux artifacts
        uses: actions/upload-artifact@v4
        with:
          name: opus-linux-x64-${{ env.BUILD_VERSION }} # Adjusted to use BUILD_VERSION
          path: opus-linux-x64-${{ env.BUILD_VERSION }}.tar.gz

  # Job for Linux ARM compilation (64-bit)
  build-linux-arm:
    name: Build on Linux ARM (64-bit)
    # Uses the latest Ubuntu version for x64, and then sets up ARM64 emulation
    runs-on: ubuntu-latest

    outputs:
      build_version: ${{ steps.date.outputs.BUILD_VERSION }} # Output the build version for other jobs

    steps:
      # Step 0: Capture build date and time to use as version
      - name: Get current date and time
        id: date
        run: |
          # Formats the date and time as INSEE_MMDD-HHMMSS (UTC)
          echo "BUILD_VERSION=$(date -u +%Y%m%d-%H%M%S)" >> "$GITHUB_ENV"
          echo "BUILD_VERSION=$(date -u +%Y%m%d-%H%M%S)" >> "$GITHUB_OUTPUT" # Output for job dependencies

      # Step 1: Set up QEMU for ARM64 emulation
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        with:
          platforms: all

      # Step 2: Set up Docker Buildx for multi-platform builds
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Step 3: Checks out your repository code
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive

      # Step 4: Build Opus for ARM inside a Docker container
      # This replaces the `apt-get` installation and direct CMake/make steps for ARM.
      # We use a multi-arch compatible Ubuntu image with build tools.
      # IMPORTANT: You might need to find a more specific cross-compiler image if
      # this base Ubuntu image doesn't have the required ARM toolchain or specific libs.
      - name: Build Opus for Linux ARM using Docker
        run: |
          # Define the target architecture and the Docker image to use
          TARGET_ARCH="arm64"
          DOCKER_IMAGE="ubuntu:noble" # Using Ubuntu Noble, you might need a more specialized cross-compiler image

          # Create the build directory on the host to store artifacts
          mkdir build-linux-arm

          # Run the build commands inside the Docker container
          docker run --rm \
            --platform linux/${TARGET_ARCH} \
            -v ${{ github.workspace }}:/src \
            -w /src \
            ${DOCKER_IMAGE} \
            /bin/bash -c "
              set -e # Exit immediately if a command exits with a non-zero status.

              echo 'Installing build dependencies inside Docker for ARM...'
              apt-get update && apt-get install -y --no-install-recommends \
                cmake \
                build-essential \
                libogg-dev \
                libflac-dev \
                libopus-dev # These packages should now be available for arm64 within the arm64 context of the container

              echo 'Configuring CMake for Linux ARM...'
              mkdir /src/build-linux-arm_docker && \
              cd /src/build-linux-arm_docker && \
              cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_SYSTEM_PROCESSOR=${TARGET_ARCH}

              echo 'Compiling Opus for Linux ARM...'
              cmake --build . --config Release

              # Change ownership of the build artifacts to the host user
              # This is crucial for the host (GitHub Actions runner) to be able to move/archive them.
              chown -R $(id -u):$(id -g) /src/build-linux-arm_docker
            "
          # Move compiled artifacts from the Docker build directory to the host build directory
          # Adjust this path based on where your compiled binaries are located within the Docker container's build dir
          # For a standard CMake build, binaries are usually in build-dir/Release/ or build-dir/Debug/
          # Copy the entire build-linux-arm_docker contents for archiving
          mv build-linux-arm_docker/* build-linux-arm/
        shell: bash

      # Step 5: Compresses build artifacts (MODIFIED to include .h headers)
      - name: Archive Linux ARM builds
        run: |
          # Creates a staging directory
          mkdir dist_linux_arm
          mkdir dist_linux_arm/bin
          mkdir -p dist_linux_arm/include/opus # Creates nested directories for headers

          # Copies compiled artifacts
          cp -r build-linux-arm/* dist_linux_arm/bin/

          # Copies Opus headers from the system installation directory
          cp -r /usr/include/opus/* dist_linux_arm/include/opus/

          # Compresses the content of the 'dist_linux_arm' directory.
          # The '-C dist_linux_arm' changes to the directory before adding '.' (current content).
          # This ensures that the root of the tar.gz file is the content of dist_linux_arm, not dist_linux_arm/dist_linux_arm/...
          tar -czvf opus-linux-arm64-${{ env.BUILD_VERSION }}.tar.gz -C dist_linux_arm .

      # Step 6: Uploads artifacts
      - name: Upload Linux ARM artifacts
        uses: actions/upload-artifact@v4
        with:
          name: opus-linux-arm64-${{ env.BUILD_VERSION }} # Adjusted to use BUILD_VERSION
          path: opus-linux-arm64-${{ env.BUILD_VERSION }}.tar.gz

  # Job to create GitHub Release
  create-release:
    name: Create GitHub Release
    # This job runs only if all build jobs succeed
    needs: [build-windows, build-linux, build-linux-arm]
    # Removed the 'if' condition, so this job now runs for every successful build on 'main'.
    runs-on: ubuntu-latest

    steps:
      # Step 0: Set the tag name based on the build version
      # We need to get the BUILD_VERSION from one of the previous jobs.
      # Since all jobs have the same BUILD_VERSION, we can pick one, e.g., build-windows.
      - name: Set Release Tag Name
        id: set_tag
        run: |
          echo "RELEASE_TAG=build-${{ needs.build-windows.outputs.build_version }}" >> $GITHUB_ENV

      # Step 1: Download all build artifacts
      - name: Download all build artifacts
        uses: actions/download-artifact@v4
        with:
          # Downloads all artifacts from the current workflow run
          path: ./artifacts

      # Step 2: List Downloaded Artifacts (for debugging)
      - name: List Downloaded Artifacts
        run: ls -R ./artifacts

      # Step 3: Create GitHub Release and upload assets
      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          # Set the tag name for the release. This action will create the tag if it doesn't exist.
          tag_name: ${{ env.RELEASE_TAG }}
          # Set the release name
          name: Automated Build Release ${{ env.RELEASE_TAG }}
          # Provide a body for the release notes
          body: |
            Automated build for branch `main`.
            Build Date (UTC): `${{ needs.build-windows.outputs.build_version }}`
          # Set 'prerelease' to true if you want these auto-generated releases to be marked as pre-releases.
          # Remove or set to 'false' if you want them as full releases.
          # prerelease: true
          files: |
            ./artifacts/opus-windows-x64-${{ needs.build-windows.outputs.build_version }}/opus-windows-x64-${{ needs.build-windows.outputs.build_version }}.zip
            ./artifacts/opus-linux-x64-${{ needs.build-linux.outputs.build_version }}/opus-linux-x64-${{ needs.build-linux.outputs.build_version }}.tar.gz
            ./artifacts/opus-linux-arm64-${{ needs.build-linux-arm.outputs.build_version }}/opus-linux-arm64-${{ needs.build-linux-arm.outputs.build_version }}.tar.gz
        env:
          # GITHUB_TOKEN is automatically provided by GitHub Actions for authentication
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
