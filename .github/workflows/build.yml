# GitHub Actions Workflow: Opus Build for Windows, Linux, and Linux ARM
#
# This workflow automates the compilation of the Opus project for Windows (x64), Linux (x64),
# and Linux ARM (64-bit). It is triggered on pushes to the 'main' branch, and now automatically
# creates a tag and release for each successful build on 'main'. It also still triggers on
# manually pushed version tags. Build artifacts are named using the UTC date and time of the build.
#
# Action Version: 1.0.14
# Last Updated: 2025-06-15
# Description of Changes:
#   - Updated Action Version and Last Updated.
#   - Confirmed that compiled binaries are uploaded as release assets.
#   - Corrected file paths in 'create-release' job's 'files' section to correctly include
#     subdirectories created by 'actions/download-artifact', ensuring assets are uploaded.
#   - Corrected Linux ARM job to use QEMU emulation on a standard x64 Ubuntu runner.
#     Removed the unsupported 'architecture' key to fix workflow validation error.
#   - Added 'docker/setup-qemu-action' and 'docker/setup-buildx-action' for ARM emulation.
#   - Ensured all comments are in English.
#   - Added steps to handle Opus header file discovery/installation in build jobs.
#     - For Linux builds, `libopus-dev` is now explicitly installed.
#     - For Windows builds, assuming Opus source is within the repo, CMake configuration remains
#       reliant on standard CMake project practices. If Opus is an external dependency,
#       additional steps (e.g., vcpkg) might be needed.
#   - **CRITICAL FIX for ARM build**: Changed ARM build to use a multi-architecture Docker
#     image for cross-compilation, bypassing apt-get package availability issues.
#
# For more information on GitHub Actions, visit: https://docs.github.com/en/actions
#

# Workflow name that will appear in GitHub Actions
name: Build Opus for Windows, Linux, and Linux ARM

# Defines when the workflow will be executed
on:
  # Triggers the workflow on 'push' events to the 'main' branch
  push:
    branches:
      - main
    tags:
      - 'v*.*.*' # Example: v1.0.0, v1.2.3 (still supported for manual tagging)

  # Allows you to manually run this workflow from the GitHub "Actions" tab
  workflow_dispatch:

# Definition of the jobs to be executed
jobs:
  # Job for Windows compilation
  build-windows:
    name: Build on Windows
    # Uses the latest Windows Server version
    runs-on: windows-latest

    outputs:
      build_version: ${{ steps.date.outputs.BUILD_VERSION }} # Output the build version for other jobs

    steps:
      # Step 0: Capture build date and time to use as version
      - name: Get current date and time
        id: date
        run: |
          # Formats the date and time as INSEE_MMDD-HHMMSS (UTC)
          $build_version = (Get-Date -UFormat %Y%m%d-%H%M%S)
          echo "BUILD_VERSION=$build_version" | Out-File -FilePath $env:GITHUB_ENV -Append
          echo "BUILD_VERSION=$build_version" | Out-File -FilePath $env:GITHUB_OUTPUT -Append # Output for job dependencies
        shell: powershell

      # Step 1: Checks out your repository code
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive # If there are submodules, they will also be cloned

      # Step 2: Configure the build environment with CMake
      # CMake is pre-installed on GitHub Actions runners
      - name: Configure CMake for Windows
        run: |
          # Creates a build directory
          mkdir build-windows
          cd build-windows
          # Configures CMake.
          # -DCMAKE_BUILD_TYPE=Release: Sets the build type to Release (optimized).
          # ..: Points to the project root directory where CMakeLists.txt is located.
          cmake .. -DCMAKE_BUILD_TYPE=Release -A x64
        # shell: cmd is used to ensure compatibility in Windows environments

      # Step 3: Compiles the project
      - name: Build Opus for Windows
        run: |
          cd build-windows
          # Compiles the project using the configuration generated by CMake
          cmake --build . --config Release

      # Step 4: Compresses build artifacts
      - name: Archive Windows builds
        run: |
          # The exact path of artifacts may vary.
          # Adjust according to where Opus files are generated (e.g., build-windows\Release\*)
          # This example attempts to copy generated files to a temporary folder and compress them.
          # You will need to check the output structure of your CMake build for 'opusfile'.
          # For a project building Opus, typically the compiled libraries/executables are in `build-windows\Release\`.
          # If opus.h is not found, it implies the compilation of Opus itself or a project
          # that depends on it is failing. This step assumes successful compilation.
          # To ensure the headers are found during compilation, verify your CMakeLists.txt
          # correctly uses `find_package(Opus CONFIG)` or `include_directories` pointing to
          # the Opus source's include path if Opus is part of your repository.
          mkdir windows_artifacts
          # Using 7-Zip (available on the Windows runner) to create the zip file
          7z a opus-windows-x64-${{ env.BUILD_VERSION }}.zip build-windows\Release\ # Adjusted to use BUILD_VERSION
        shell: powershell

      # Step 5: Uploads artifacts
      - name: Upload Windows artifacts
        uses: actions/upload-artifact@v4
        with:
          # Artifact name
          name: opus-windows-x64-${{ env.BUILD_VERSION }} # Adjusted to use BUILD_VERSION
          # Path to the file or directory to be uploaded
          path: opus-windows-x64-${{ env.BUILD_VERSION }}.zip


  # Job for Linux compilation (x64)
  build-linux:
    name: Build on Linux (x64)
    # Uses the latest Ubuntu version (x64 by default)
    runs-on: ubuntu-latest

    outputs:
      build_version: ${{ steps.date.outputs.BUILD_VERSION }} # Output the build version for other jobs

    steps:
      # Step 0: Capture build date and time to use as version
      - name: Get current date and time
        id: date
        run: |
          # Formats the date and time as INSEE_MMDD-HHMMSS (UTC)
          echo "BUILD_VERSION=$(date -u +%Y%m%d-%H%M%S)" >> "$GITHUB_ENV"
          echo "BUILD_VERSION=$(date -u +%Y%m%d-%H%M%S)" >> "$GITHUB_OUTPUT" # Output for job dependencies

      # Step 1: Checks out your repository code
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive

      # Step 2: Installs build tools (CMake, make, etc.) and Opus development headers
      - name: Install build dependencies and Opus development headers
        run: |
          sudo apt-get update
          # `libopus-dev` provides `opus.h` and other necessary development files for Opus.
          # `libogg-dev` and `libflac-dev` are also included as they might be dependencies
          # for projects using Opus (e.g., opusfile).
          sudo apt-get install -y cmake build-essential libogg-dev libflac-dev libopus-dev

      # Step 3: Configures the build environment with CMake
      - name: Configure CMake for Linux
        run: |
          mkdir build-linux
          cd build-linux
          cmake .. -DCMAKE_BUILD_TYPE=Release # Release compilation for optimization

      # Step 4: Compiles the project
      - name: Build Opus for Linux
        run: |
          cd build-linux
          cmake --build . --config Release # Uses 'make' underneath

      # Step 5: Compresses build artifacts
      - name: Archive Linux builds
        run: |
          # Compresses the content of the 'build-linux' directory.
          # The '-C build-linux' changes to the directory before adding '.' (current content).
          # This ensures that the root of the tar.gz file is the content of build-linux, and not build-linux/build-linux/...
          tar -czvf opus-linux-x64-${{ env.BUILD_VERSION }}.tar.gz -C build-linux .
      # Explicit 'shell: /usr/bin/bash -e {0}' is not necessary, default is bash on Linux

      # Step 6: Uploads artifacts
      - name: Upload Linux artifacts
        uses: actions/upload-artifact@v4
        with:
          name: opus-linux-x64-${{ env.BUILD_VERSION }} # Adjusted to use BUILD_VERSION
          path: opus-linux-x64-${{ env.BUILD_VERSION }}.tar.gz

  # Job for Linux ARM compilation (64-bit)
  build-linux-arm:
    name: Build on Linux ARM (64-bit)
    # Uses the latest Ubuntu version for x64, and then sets up ARM64 emulation
    runs-on: ubuntu-latest

    outputs:
      build_version: ${{ steps.date.outputs.BUILD_VERSION }} # Output the build version for other jobs

    steps:
      # Step 0: Capture build date and time to use as version
      - name: Get current date and time
        id: date
        run: |
          # Formats the date and time as INSEE_MMDD-HHMMSS (UTC)
          echo "BUILD_VERSION=$(date -u +%Y%m%d-%H%M%S)" >> "$GITHUB_ENV"
          echo "BUILD_VERSION=$(date -u +%Y%m%d-%H%M%S)" >> "$GITHUB_OUTPUT" # Output for job dependencies

      # Step 1: Set up QEMU for ARM64 emulation
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        with:
          platforms: all

      # Step 2: Set up Docker Buildx for multi-platform builds
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Step 3: Checks out your repository code
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive

      # Step 4: Build Opus for ARM inside a Docker container
      # This replaces the `apt-get` installation and direct CMake/make steps for ARM.
      # We use a multi-arch compatible Ubuntu image with build tools.
      # IMPORTANT: You might need to find a more specific cross-compilation image if
      # this base Ubuntu image doesn't have the required ARM toolchain or specific libs.
      - name: Build Opus for Linux ARM using Docker
        run: |
          # Define the target architecture and the Docker image to use
          TARGET_ARCH="arm64"
          DOCKER_IMAGE="ubuntu:noble" # Using Ubuntu Noble, you might need a more specialized cross-compiler image

          # Create the build directory on the host to store artifacts
          mkdir build-linux-arm

          # Run the build commands inside the Docker container
          docker run --rm \
            --platform linux/${TARGET_ARCH} \
            -v ${{ github.workspace }}:/src \
            -w /src \
            ${DOCKER_IMAGE} \
            /bin/bash -c "
              set -e # Exit immediately if a command exits with a non-zero status.

              echo 'Installing build dependencies inside Docker for ARM...'
              apt-get update && apt-get install -y --no-install-recommends \
                cmake \
                build-essential \
                libogg-dev \
                libflac-dev \
                libopus-dev # These packages should now be available for arm64 within the arm64 context of the container

              echo 'Configuring CMake for Linux ARM...'
              mkdir /src/build-linux-arm_docker && \
              cd /src/build-linux-arm_docker && \
              cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_SYSTEM_PROCESSOR=${TARGET_ARCH}

              echo 'Compiling Opus for Linux ARM...'
              cmake --build . --config Release
            "
          # Move compiled artifacts from the Docker build directory to the host build directory
          # Adjust this path based on where your compiled binaries are located within the Docker container's build dir
          # For a standard CMake build, binaries are usually in build-dir/Release/ or build-dir/Debug/
          # Copy the entire build-linux-arm_docker contents for archiving
          mv build-linux-arm_docker/* build-linux-arm/
        shell: bash

      # Step 5: Compresses build artifacts
      - name: Archive Linux ARM builds
        run: |
          # Compresses the content of the 'build-linux-arm' directory.
          tar -czvf opus-linux-arm64-${{ env.BUILD_VERSION }}.tar.gz -C build-linux-arm .

      # Step 6: Uploads artifacts
      - name: Upload Linux ARM artifacts
        uses: actions/upload-artifact@v4
        with:
          name: opus-linux-arm64-${{ env.BUILD_VERSION }} # Adjusted to use BUILD_VERSION
          path: opus-linux-arm64-${{ env.BUILD_VERSION }}.tar.gz

  # Job to create GitHub Release
  create-release:
    name: Create GitHub Release
    # This job runs only if all build jobs succeed
    needs: [build-windows, build-linux, build-linux-arm]
    # Removed the 'if' condition, so this job now runs for every successful build on 'main'.
    runs-on: ubuntu-latest

    steps:
      # Step 0: Set the tag name based on the build version
      # We need to get the BUILD_VERSION from one of the previous jobs.
      # Since all jobs have the same BUILD_VERSION, we can pick one, e.g., build-windows.
      - name: Set Release Tag Name
        id: set_tag
        run: |
          echo "RELEASE_TAG=build-${{ needs.build-windows.outputs.build_version }}" >> $GITHUB_ENV

      # Step 1: Download all build artifacts
      - name: Download all build artifacts
        uses: actions/download-artifact@v4
        with:
          # Downloads all artifacts from the current workflow run
          path: ./artifacts

      # Step 2: List downloaded artifacts (for debugging)
      - name: List Downloaded Artifacts
        run: ls -R ./artifacts

      # Step 3: Create GitHub Release and upload assets
      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          # Set the tag name for the release. This action will create the tag if it doesn't exist.
          tag_name: ${{ env.RELEASE_TAG }}
          # Set the release name
          name: Automated Build Release ${{ env.RELEASE_TAG }}
          # Provide a body for the release notes
          body: |
            Automated build for branch `main`.
            Build Date (UTC): `${{ needs.build-windows.outputs.build_version }}`
          # Set 'prerelease' to true if you want these auto-generated releases to be marked as pre-releases.
          # Remove or set to 'false' if you want them as full releases.
          # prerelease: true
          files: |
            ./artifacts/opus-windows-x64-${{ needs.build-windows.outputs.build_version }}/opus-windows-x64-${{ needs.build-windows.outputs.build_version }}.zip
            ./artifacts/opus-linux-x64-${{ needs.build-linux.outputs.build_version }}/opus-linux-x64-${{ needs.build-linux.outputs.build_version }}.tar.gz
            ./artifacts/opus-linux-arm64-${{ needs.build-linux-arm.outputs.build_version }}/opus-linux-arm64-${{ needs.build-linux-arm.outputs.build_version }}.tar.gz
        env:
          # GITHUB_TOKEN is automatically provided by GitHub Actions for authentication
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}